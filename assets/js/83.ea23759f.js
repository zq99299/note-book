(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{1709:function(v,_,t){"use strict";t.r(_);var i=t(13),s=Object(i.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"_085-hystrix-要解决的分布式系统可用性问题以及其设计原则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_085-hystrix-要解决的分布式系统可用性问题以及其设计原则"}},[v._v("#")]),v._v(" 085. hystrix 要解决的分布式系统可用性问题以及其设计原则")]),v._v(" "),i("p",[v._v("我们的主题是：高可用性，会用几讲的时间来讲解一下如何用 hystrix 来构建高可用的服务的架构，\n咱们会用一个真实的项目背景，作为业务场景，来带出来在这个特定的业务场景下，\n可能会产生哪些各种各样的可用性的一些问题，针对这些问题，我们用 hystrix 的解决方案和原理是什么？")]),v._v(" "),i("p",[v._v("带着大家，纯手工将所有的服务的高可用架构的代码，全部纯手工自己敲出来，形成高可用服务架构的项目实战的一个课程")]),v._v(" "),i("h2",{attrs:{id:"hystrix-是什么"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hystrix-是什么"}},[v._v("#")]),v._v(" hystrix 是什么？")]),v._v(" "),i("p",[v._v("在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。")]),v._v(" "),i("p",[v._v("Hystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。\nHystrix 通过将依赖服务进行资源隔离，进而阻止某个依赖服务出现故障的时候，这种故障在整个系统所有的依赖服务调用中进行蔓延，\n同时 Hystrix 还提供故障时的 fallback 降级机制")]),v._v(" "),i("p",[v._v("总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性")]),v._v(" "),i("p",[v._v("上面一段文字用下图示意")]),v._v(" "),i("p",[i("img",{attrs:{src:t(490),alt:""}})]),v._v(" "),i("p",[v._v("疑问：看完还是没有概念能打消想知道 b 服务不能使用时怎么能保证，a 服务功能完整性?")]),v._v(" "),i("h2",{attrs:{id:"hystrix-的历史"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hystrix-的历史"}},[v._v("#")]),v._v(" Hystrix 的历史")]),v._v(" "),i("p",[v._v("hystrix 就是一种高可用保障的一个框架，类似于 spring（ioc、mvc）、mybatis、activiti、lucene 框架，\n预先封装好的为了解决某个特定领域的特定问题的一套代码库，用了框架来解决这个领域的特定的问题，\n就可以大大减少我们的工作量，提升我们的工作质量和工作效率")]),v._v(" "),i("p",[v._v("Netflix（网飞公司，美国流媒体巨头、世界最大的收费视频网站网飞），API 团队从 2011 年开始做一些提升系统可用性和稳定性的工作，\nHystrix 就是从那时候开始发展出来的。在 2012 年的时候，Hystrix 就变得比较成熟和稳定了，\nNetflix 中，除了 API 团队以外，很多其他的团队都开始使用 Hystrix。")]),v._v(" "),i("p",[v._v("时至今日，Netflix 中每天都有数十亿次的服务间调用，通过 Hystrix 框架在进行，\n而 Hystrix 也帮助 Netflix 网站提升了整体的可用性和稳定性")]),v._v(" "),i("h2",{attrs:{id:"初步看一看-hystrix-的设计原则是什么"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#初步看一看-hystrix-的设计原则是什么"}},[v._v("#")]),v._v(" 初步看一看 Hystrix 的设计原则是什么？")]),v._v(" "),i("p",[v._v("hystrix 为了实现高可用性的架构，设计 hystrix 的时候，一些设计原则是什么？")]),v._v(" "),i("ol",[i("li",[i("p",[v._v("对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护")])]),v._v(" "),i("li",[i("p",[v._v("在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延")]),v._v(" "),i("p",[v._v("服务 A - 服务 B -> 服务 C，服务 C 故障了，服务 B 也故障了，服务 A 故障了，整套分布式系统全部故障，整体宕机")])]),v._v(" "),i("li",[i("p",[v._v("提供 fail-fast（快速失败）和快速恢复的支持")])]),v._v(" "),i("li",[i("p",[v._v("提供 fallback 优雅降级的支持")])]),v._v(" "),i("li",[i("p",[v._v("支持近实时的监控、报警以及运维操作")])])]),v._v(" "),i("p",[v._v("关键词总结：")]),v._v(" "),i("ul",[i("li",[v._v("调用延迟 + 失败，提供容错")]),v._v(" "),i("li",[v._v("阻止故障蔓延")]),v._v(" "),i("li",[v._v("快速失败 + 快速恢复")]),v._v(" "),i("li",[v._v("降级")]),v._v(" "),i("li",[v._v("监控 + 报警 + 运维")])]),v._v(" "),i("p",[v._v("这里不是完全描述了 hystrix 的功能，简单来说是按照这些原则来设计 hystrix ，提供整个分布式系统的高可用的架构")]),v._v(" "),i("h2",{attrs:{id:"hystrix-要解决的问题是什么"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hystrix-要解决的问题是什么"}},[v._v("#")]),v._v(" Hystrix 要解决的问题是什么？")]),v._v(" "),i("p",[v._v("在复杂的分布式系统架构中，每个服务都有很多的依赖服务，而每个依赖服务都可能会故障，\n如果服务没有和自己的依赖服务进行隔离，那么可能某一个依赖服务的故障就会拖垮当前这个服务")]),v._v(" "),i("p",[i("strong",[v._v("举例来说：某个服务有 30 个依赖服务，每个依赖服务的可用性非常高，已经达到了 99.99% 的高可用性")])]),v._v(" "),i("p",[v._v("那么该服务的可用性就是 99.99% - （100% - 99.99% * 30 = 0.3%）= 99.69%，\n意味着 3% 的请求可能会失败，因为 3% 的时间内系统可能出现了故障不可用了")]),v._v(" "),i("p",[v._v("对于 1 亿次访问来说，3% 的请求失败也就意味着 300万 次请求会失败，也意味着每个月有 2个 小时的时间系统是不可用的，\n在真实生产环境中，可能更加糟糕")]),v._v(" "),i("p",[v._v("上面的描述想表达的意思是：即使你每个依赖服务都是 99.99% 高可用性，但是一旦你有几十个依赖服务，\n还是会导致你每个月都有几个小时是不可用的")]),v._v(" "),i("p",[v._v("下面画图分析说，当某一个依赖服务出现了调用延迟或者调用失败时，为什么会拖垮当前这个服务？\n以及在分布式系统中，故障是如何快速蔓延的？")]),v._v(" "),i("p",[i("img",{attrs:{src:t(491),alt:""}})]),v._v(" "),i("p",[v._v("简而言之：")]),v._v(" "),i("ol",[i("li",[v._v("假设只有系统承受并发能力是 100 个线程，")]),v._v(" "),i("li",[v._v("C 出问题的时候，耗时增加，将导致当前进入的 40 个线程得不到释放")]),v._v(" "),i("li",[v._v("后续大量的请求涌进来，也是先调用 c，然后又在这里了")]),v._v(" "),i("li",[v._v("最后 100 个线程都被卡在 c 了，资源耗尽，导致整个服务不能提供服务")]),v._v(" "),i("li",[v._v("那么其他依赖的服务也会出现上述问题，导致整个系统全盘崩溃")])]),v._v(" "),i("p",[v._v("当时这个只能是在 高并发高流量的场景下会出现这种情况，其实我工作中也遇到过一次真实的案例，\nquartz 默认线程只有 25 个，当时定时任务接近 150 个左右，平时每个定时任务触发时间基本上上分散的，\n而且基本上在 10 分钟左右会结束任务，当我们调用其他第三方服务时，没有加超时功能，\n第三方服务可能出问题了，导致我们的请求被卡主，进而导致任务线程不能结束，最后整个任务调度系统完全崩溃，\n完全不能提供服务。")]),v._v(" "),i("p",[v._v("这个场景在我所工作生涯中可能是记忆最深的一次了，因为当时在线上，根据日志打印完全看不出来问题，\n就像系统假死一样，后来通过 jconsole 查看线程挂起情况，发现所有线程调用第三方服务后都被卡主了。\n才顺藤摸瓜找到 quartz 的默认线程只有 25 个。最后加大了线程，也只是治标不治本，长时间运行还是会出问题")]),v._v(" "),i("h2",{attrs:{id:"再看-hystrix-的更加细节的设计原则是什么"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#再看-hystrix-的更加细节的设计原则是什么"}},[v._v("#")]),v._v(" 再看 hystrix 的更加细节的设计原则是什么？")]),v._v(" "),i("ol",[i("li",[i("p",[v._v("阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源")])]),v._v(" "),i("li",[i("p",[v._v("避免请求排队和积压，采用限流和 fail fast 来控制故障")])]),v._v(" "),i("li",[i("p",[v._v("提供 fallback 降级机制来应对故障")])]),v._v(" "),i("li",[i("p",[v._v("使用资源隔离技术")]),v._v(" "),i("p",[v._v("隔离技术是为了实现第一条的功能")]),v._v(" "),i("p",[v._v("比如 bulkhead（舱壁隔离技术），swimlane（泳道技术），circuit breaker（短路技术），\n来限制任何一个依赖服务的故障的影响")])]),v._v(" "),i("li",[i("p",[v._v("通过近实时的统计/监控/报警功能，来提高故障发现的速度")])]),v._v(" "),i("li",[i("p",[v._v("通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度")])]),v._v(" "),i("li",[i("p",[v._v("保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况")]),v._v(" "),i("p",[v._v("调用这个依赖服务的时候，client 调用包有 bug、阻塞，等等")]),v._v(" "),i("p",[v._v("依赖服务的各种各样的 "),i("strong",[v._v("调用的故障")]),v._v("，都可以处理")])])]),v._v(" "),i("h2",{attrs:{id:"hystrix-是如何实现它的目标的"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hystrix-是如何实现它的目标的"}},[v._v("#")]),v._v(" Hystrix 是如何实现它的目标的？")]),v._v(" "),i("ol",[i("li",[i("p",[v._v("通过 HystrixCommand 或者 HystrixObservableCommand 来封装对外部依赖的访问请求\nd\n这个访问请求一般会运行在独立的线程中，资源隔离")])]),v._v(" "),i("li",[i("p",[v._v("对于超出我们设定阈值的服务调用，直接进行超时，不允许其耗费过长时间阻塞住。")]),v._v(" "),i("p",[v._v("这个超时时间默认是 99.5% 的访问时间，但是一般我们可以自己设置一下")])]),v._v(" "),i("li",[i("p",[v._v("为每一个依赖服务维护一个独立的线程池，或者是 semaphore(信号量)，当线程池已满时，直接拒绝对这个服务的调用")])]),v._v(" "),i("li",[i("p",[v._v("对依赖服务的调用的成功次数、失败次数、拒绝次数、超时次数，进行统计")])]),v._v(" "),i("li",[i("p",[v._v("如果对一个依赖服务的调用失败次数超过了一定的阈值，自动进行熔断")]),v._v(" "),i("p",[v._v("在一定时间内对该服务的调用直接降级，一段时间后再自动尝试恢复")])]),v._v(" "),i("li",[i("p",[v._v("当一个服务调用出现失败、被拒绝、超时、短路（熔断）等异常情况时，自动调用 fallback 降级机制")])]),v._v(" "),i("li",[i("p",[v._v("对属性和配置的修改提供近实时的支持")])])]),v._v(" "),i("p",[i("img",{attrs:{src:t(492),alt:""}})]),v._v(" "),i("p",[v._v("疑问：上图只是站在全局角度来看的？并非自己所想，当一个依赖故障的时候，怎么搞也拿不到正确数据了？关注点关注错了？意思是说，及时这个一个小功能点不能用了，但是该系统其它的功能点能正常使用。并且不会因为这个故障导致整个系统崩溃？")]),v._v(" "),i("h2",{attrs:{id:"《亿级流量电商详情页系统的大型高并发与高可用缓存架构实战》功能回顾"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#《亿级流量电商详情页系统的大型高并发与高可用缓存架构实战》功能回顾"}},[v._v("#")]),v._v(" 《亿级流量电商详情页系统的大型高并发与高可用缓存架构实战》功能回顾")]),v._v(" "),i("p",[v._v("由于该章节稍微独立，所以需要照顾下这个独立同学的上下文知识点，回顾下这个主题的功能点")]),v._v(" "),i("ol",[i("li",[v._v("亿级流量的电商网站的商品详情页系统架构")]),v._v(" "),i("li",[v._v("大型的缓存架构，支撑高并发与高可用")]),v._v(" "),i("li",[v._v("几十万 QPS 的高并发 + 99.99% 高可用 + 1T 以上的海量数据 + 绝对数据安全的 redis 集群架构")]),v._v(" "),i("li",[v._v("高并发场景下的数据库 + 缓存双写一致性保障方案")]),v._v(" "),i("li",[v._v("大缓存的维度化拆分方案")]),v._v(" "),i("li",[v._v("基于双层 nginx 部署架构的缓存命中率提升方案")]),v._v(" "),i("li",[v._v("基于 kafka + spring boot + ehcache + redis + nginx + lua 的多级缓存架构")]),v._v(" "),i("li",[v._v("基于 zookeeper 的缓存并发更新安全保障方案")]),v._v(" "),i("li",[v._v("基于 storm + zookeeper 的大规模缓存预热解决方案")]),v._v(" "),i("li",[v._v("基于 storm + zookeeper + nginx + lua 的热点缓存自动降级与恢复解决方案")]),v._v(" "),i("li",[v._v("基于 hystrix 的高可用缓存服务架构")]),v._v(" "),i("li",[v._v("hystrix 的进阶高可用架构方案、架构性能优化以及监控运维")]),v._v(" "),i("li",[v._v("基于 hystrix 的大规模缓存雪崩解决方案")]),v._v(" "),i("li",[v._v("高并发场景下的缓存穿透解决方案")]),v._v(" "),i("li",[v._v("高并发场景下的缓存失效解决方案")])])])}),[],!1,null,null,null);_.default=s.exports},490:function(v,_,t){v.exports=t.p+"assets/img/markdown-img-paste-20190529231638719.23c04f89.png"},491:function(v,_,t){v.exports=t.p+"assets/img/markdown-img-paste-20190529235104136.80d6b8d9.png"},492:function(v,_,t){v.exports=t.p+"assets/img/markdown-img-paste-20190530214412325.5518e01b.png"}}]);