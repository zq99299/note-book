(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{1500:function(s,a,t){s.exports=t.p+"assets/img/e3e052fac55209937cfd20ab5117f24f.e3e052fa.png"},1501:function(s,a,t){s.exports=t.p+"assets/img/c7e756e33fd5ce6156e35d8ec66e2df7.c7e756e3.png"},1502:function(s,a,t){s.exports=t.p+"assets/img/4386yyd95dc71323098e9c6ae187645f.4386add9.png"},1503:function(s,a,t){s.exports=t.p+"assets/img/f60e745b693a11d50e4c41b02f9f4c1a.f60e745b.jpg"},1504:function(s,a,t){s.exports=t.p+"assets/img/f2aac8643c053fd7fb010e18f9431624.f2aac864.jpg"},1505:function(s,a,t){s.exports=t.p+"assets/img/ac99c68754d4e6c54d958970e9c3a5fb.ac99c687.png"},1506:function(s,a,t){s.exports=t.p+"assets/img/10160dab5ccfcffb63abd79fc2299528.10160dab.png"},1507:function(s,a,t){s.exports=t.p+"assets/img/0646f1d176e08cbeayyf005495e301f2.0646f1d1.png"},1508:function(s,a,t){s.exports=t.p+"assets/img/1f8860d7fd9f0bf88cc6b3be2e08e937.1f8860d7.png"},1509:function(s,a,t){s.exports=t.p+"assets/img/a7438f0dc228edcb21fa69cd2fca8979.a7438f0d.png"},1510:function(s,a,t){s.exports=t.p+"assets/img/b12a4239a5ee7a1071e7752d19ba23bd.b12a4239.png"},1511:function(s,a,t){s.exports=t.p+"assets/img/7c2c0660cb4187fc7e9e9c60a827ce07.7c2c0660.png"},1512:function(s,a){s.exports="data:image/png;base64,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"},1513:function(s,a,t){s.exports=t.p+"assets/img/image-20210112112818541.8d25e58e.png"},2137:function(s,a,t){"use strict";t.r(a);var n=t(13),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"_11丨如何理解正则的匹配原理以及优化原则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11丨如何理解正则的匹配原理以及优化原则"}},[s._v("#")]),s._v(" 11丨如何理解正则的匹配原理以及优化原则？")]),s._v(" "),n("p",[s._v("这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。")]),s._v(" "),n("p",[s._v("这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。")]),s._v(" "),n("h2",{attrs:{id:"有穷状态自动机"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有穷状态自动机"}},[s._v("#")]),s._v(" 有穷状态自动机")]),s._v(" "),n("p",[s._v("正则之所以能够处理复杂文本，就是因为采用了 "),n("strong",[s._v("有穷状态自动机（finite automaton）。")]),s._v(" 那什么是有穷自动机呢？")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。")])]),s._v(" "),n("li",[n("p",[s._v("自动机是指系统可以根据相应的条件，在不同的状态下进行转移。")]),s._v(" "),n("p",[s._v("从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。")])])]),s._v(" "),n("p",[s._v("有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA：")]),s._v(" "),n("ul",[n("li",[s._v("DFA：确定性有穷自动机（Deterministic finite automaton）")]),s._v(" "),n("li",[s._v("NFA：非确定性有穷自动机（Non-deterministic finite automaton）\n"),n("ul",[n("li",[s._v("传统的 NFA")]),s._v(" "),n("li",[s._v("POSIX NFA")])])])]),s._v(" "),n("p",[s._v("接下来我们来通过一些示例，来详细看下正则表达式的匹配过程。")]),s._v(" "),n("h2",{attrs:{id:"正则的匹配过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则的匹配过程"}},[s._v("#")]),s._v(" 正则的匹配过程")]),s._v(" "),n("p",[s._v("在使用到编程语言时，我们经常会 「编译」一下正则表达式，来提升效率，比如在 Python3 中它是下面这样的：")]),s._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" re\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" reg "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" re"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("compile")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("r'a(?:bb)+a'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" reg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("findall"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abbbba'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abbbba'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("这个编译的过程，"),n("strong",[s._v("其实就是生成自动机的过程")]),s._v("，正则引擎会拿着这个自动机去和字符串进行匹配。生成的自动机可能是这样的（下图是使用 "),n("a",{attrs:{href:"https://github.com/javallone/regexper-static",target:"_blank",rel:"noopener noreferrer"}},[s._v("Regexper 工具生成"),n("OutboundLink")],1),s._v("，再次加工得到的）。比如上图中的 "),n("code",[s._v("a(?:bb)+a")]),s._v(" 可以 "),n("a",{attrs:{href:"https://regexper.com/#a%28%3F%3Abb%29%2Ba",target:"_blank",rel:"noopener noreferrer"}},[s._v("使用在线的 Regexper 工具生成下图类似的图片"),n("OutboundLink")],1),s._v(" （友情提示："),n("code",[s._v("(?:)")]),s._v(" 小括号中的 "),n("code",[s._v("?:")]),s._v(" 表示不捕获分组）")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1500),alt:"img"}})]),s._v(" "),n("p",[s._v("在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 "),n("code",[s._v("a(bb)+a")]),s._v("  在匹配了字符 "),n("code",[s._v("abb")]),s._v(" 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。"),n("strong",[s._v("这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）")]),s._v("。")]),s._v(" "),n("p",[n("strong",[s._v("NFA 和 DFA 是可以相互转化的，")]),s._v(" 当我们把上面的状态表示成下面这样，就是一台 DFA 状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1501),alt:"img"}})]),s._v(" "),n("p",[s._v("那这两种状态机的工作方式到底有什么不同呢？我们接着往下看。")]),s._v(" "),n("h2",{attrs:{id:"dfa-nfa-工作机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dfa-nfa-工作机制"}},[s._v("#")]),s._v(" DFA& NFA 工作机制")]),s._v(" "),n("p",[s._v("下面我通过一个示例，来简单说明 "),n("strong",[s._v("NFA 与 DFA 引擎工作方式的区别")]),s._v("：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("字符串：we study on jikeshijian app\n正则：jike(zhushou|shijian|shixi)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h3",{attrs:{id:"nfa-引擎工作方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nfa-引擎工作方式"}},[s._v("#")]),s._v(" NFA 引擎工作方式")]),s._v(" "),n("p",[n("strong",[s._v("NFA 引擎的工作方式是")]),s._v("，先看正则，再看文本，而且以正则为主导。")]),s._v(" "),n("p",[s._v("正则中的第一个字符是 j，NFA 引擎在字符串中查找 j，接着匹配其后是否为 i ，如果是 i 则继续，这样一直找到 jike。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\nregex: jike(zhushou|shijian|shixi)\n          ^\ntext: we study on jikeshijian app\n                     ^\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("我们再根据正则看文本后面是不是 z，发现不是，此时 zhushou 分支淘汰。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("regex: jike(zhushou|shijian|shixi)\n            ^\n         淘汰此分支(zhushou)\ntext: we study on jikeshijian app\n                      ^\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("我们接着看其它的分支，看文本部分是不是 s，直到 shijian 整个匹配上。shijian 在匹配过程中如果不失败，就不会看后面的 shixi 分支。当匹配上了 shijian 后，整个文本匹配完毕，也不会再看 shixi 分支。")]),s._v(" "),n("p",[s._v("假设这里文本改一下，把 jikeshijian 变成 jikeshixi，正则 shi"),n("strong",[s._v("j")]),s._v("ian 的 j 匹配不上时 shixi 的 x，会接着使用正则 shixi 来进行匹配，重新从 s 开始（NFA 引擎会记住这里）。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\n第二个分支匹配失败\nregex: jike(zhushou|shijian|shixi)\n                       ^\n                  淘汰此分支(正则j匹配不上文本x)\ntext: we study on jikeshixi app\n                         ^\n再次尝试第三个分支\nregex: jike(zhushou|shijian|shixi)\n                            ^\ntext: we study on jikeshixi app\n                      ^\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("p",[s._v("也就是说， "),n("strong",[s._v("NFA 是以正则为主导，反复测试字符串")]),s._v("，这样字符串中同一部分，有可能被反复测试很多次。")]),s._v(" "),n("h3",{attrs:{id:"dfa-引擎工作方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dfa-引擎工作方式"}},[s._v("#")]),s._v(" DFA 引擎工作方式")]),s._v(" "),n("p",[s._v("而 DFA 不是这样的，"),n("strong",[s._v("DFA 会先看文本，再看正则表达式，是以文本为主导的")]),s._v("。")]),s._v(" "),n("p",[s._v("在具体匹配过程中，DFA 会从 we 中的 w 开始依次查找 j，定位到 j ，这个字符后面是 i。所以我们接着看正则部分是否有 i ，如果正则后面是个 i ，那就以同样的方式，匹配到后面的 ke。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("text: we study on jikeshijian app\n                     ^\nregex: jike(zhushou|shijian|shixi)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("继续进行匹配，文本 e 后面是字符 s ，DFA 接着看正则表达式部分，此时 zhushou 分支被淘汰，开头是 s 的分支 shijian 和 shixi 符合要求。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\ntext: we study on jikeshijian app\n                      ^\nregex: jike(zhushou|shijian|shixi)\n            ^       ^       ^\n           淘汰     符合    符合\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("然后 DFA 依次检查字符串，检测到 shijian 中的 j 时，只有 shijian 分支符合，淘汰 shixi，接着看分别文本后面的 ian，和正则比较，匹配成功。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\ntext: we study on jikeshijian app\n                         ^\nregex: jike(zhushou|shijian|shixi)\n                       ^       ^\n                      符合     淘汰\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("从这个示例你可以看到，DFA 和 NFA 两种引擎的工作方式完全不同。")]),s._v(" "),n("ul",[n("li",[s._v("NFA 是以表达式为主导的，先看正则表达式，再看文本。")]),s._v(" "),n("li",[s._v("而 DFA 则是以文本为主导，先看文本，再看正则表达式。")])]),s._v(" "),n("p",[s._v("一般来说，DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次。也就是说 DFA 引擎执行的时间一般是线性的。DFA 引擎可以确保匹配到可能的最长字符串。"),n("strong",[s._v("但由于 DFA 引擎只包含有限的状态，所以它没有反向引用功能")]),s._v("；并且因为它不构造显示扩展，它也不支持捕获子组。")]),s._v(" "),n("p",[s._v("NFA  以表达式为主导，它的引擎是使用  "),n("strong",[s._v("贪心匹配回溯算法实现")]),s._v("。NFA  通过构造特定扩展，支持子组和反向引用。但由于 NFA 引擎会发生回溯，即它会对字符串中的同一部分，进行很多次对比。因此，在最坏情况下，它的执行速度可能非常慢。")]),s._v(" "),n("h2",{attrs:{id:"posix-nfa-与-传统-nfa-区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#posix-nfa-与-传统-nfa-区别"}},[s._v("#")]),s._v(" POSIX NFA 与 传统 NFA 区别")]),s._v(" "),n("p",[s._v("因为传统的 NFA 引擎「急于」报告匹配结果，找到第一个匹配上的就返回了，所以可能会导致还有更长的匹配未被发现。比如使用正则 "),n("code",[s._v("pos|posix")]),s._v("  在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1502),alt:"img"}})]),s._v(" "),n("p",[s._v("POSIX NFA 的应用很少，主要是 Unix/Linux 中的某些工具。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（"),n("code",[s._v("The Longest-Leftmost")]),s._v("）。因此，POSIX NFA 引擎的速度要慢于传统的 NFA 引擎。")]),s._v(" "),n("p",[s._v("我们日常面对的，"),n("strong",[s._v("一般都是传统的 NFA，所以通常都是 最左侧 的分支优先")]),s._v("，在书写正则的时候务必要注意这一点。")]),s._v(" "),n("p",[s._v("下面是 DFA、传统 NFA 以及 POSIX NFA 引擎的特点总结：")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1503),alt:"img"}})]),s._v(" "),n("h2",{attrs:{id:"回溯"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[s._v("#")]),s._v(" 回溯")]),s._v(" "),n("p",[s._v("回溯是 NFA 引擎才有的，并且只有在正则中出现 "),n("strong",[s._v("量词")]),s._v(" 或 "),n("strong",[s._v("多选分支结构")]),s._v(" 时，才可能会发生回溯。")]),s._v(" "),n("p",[s._v("比如我们使用正则 "),n("code",[s._v("a+ab")]),s._v(" 来匹配 文本  "),n("code",[s._v("aab")]),s._v(" 的时候，过程是这样的：")]),s._v(" "),n("ol",[n("li",[n("code",[s._v("a+")]),s._v(" 是贪婪匹配，会占用掉文本中的两个 a")]),s._v(" "),n("li",[s._v("但正则接着又是 a，文本部分只剩下 b，只能通过回溯，让 "),n("code",[s._v("a+")]),s._v(" 吐出一个 a，再次尝试。")])]),s._v(" "),n("p",[s._v("如果正则是使用 "),n("code",[s._v(".*ab")]),s._v(" 去匹配一个比较长的字符串就更糟糕了，因为 "),n("code",[s._v(".*")]),s._v(" 会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将 "),n("code",[s._v(".*")]),s._v("  匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1504),alt:"img"}})]),s._v(" "),n("p",[s._v("所以在工作中，我们要尽量不用 "),n("code",[s._v(".*")]),s._v("  ，除非真的有必要，因为点能匹配的范围太广了，"),n("strong",[s._v("我们要尽可能精确")]),s._v("。常见的解决方式有两种，比如要提取引号中的内容时：")]),s._v(" "),n("ul",[n("li",[s._v("使用 "),n("code",[s._v('[^"]+')])]),s._v(" "),n("li",[s._v("或者使用非贪婪的方式 "),n("code",[s._v(".+?")]),s._v(" ，来减少 "),n("strong",[s._v("匹配上的内容不断吐出，再次尝试")]),s._v(" 的过程。")])]),s._v(" "),n("p",[s._v("我们再回头看一下之前讲解的店铺名匹配示例：")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1505),alt:"img"}})]),s._v(" "),n("p",[s._v("为了简单，笔者测试的文本和正则如下（除了匹配步骤是 43 次之外，回溯是从 "),n("code",[s._v("cat,")]),s._v(" t 开始回溯的）")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("正则：^([A-Za-z0-9._()&'\\- ])+$\n文本：this is a cat, cat\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("从示例（图例右上角）我们可以看到，一个很短的字符串，NFA 引擎尝试步骤达到了 9021 次，由于是贪婪匹配，第一个分支能匹配上 "),n("code",[s._v("this is a cat")]),s._v(" 部分，接着后面的逗号匹配失败，使用第二个分支匹配，再次失败，此时贪婪匹配部分结束。NFA 引擎接着用正则后面的 "),n("code",[s._v("$")]),s._v(" 来进行匹配，但此处不是文本结尾，匹配不上，发生回溯，吐出第一个分支匹配上的 t，使用第二个分支匹配 t 再试，还是匹配不上。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1506),alt:"img"}})]),s._v(" "),n("p",[s._v("我们继续回溯，第二个分支匹配上的 t 吐出，第一个分支匹配上的 a 也吐出，再用第二个分支匹配 a 再试，如此发生了大量的回溯。你可以使用 regex101.com 中的 Regex Debugger 来调试一下这个过程，加深你的理解。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1507),alt:"img"}})]),s._v(" "),n("p",[n("img",{attrs:{src:t(1508),alt:"img"}})]),s._v(" "),n("p",[s._v("我们来尝试优化一下，把第一个分支中的 "),n("code",[s._v("A-Za-z")]),s._v(" 去掉，因为后面多选分支结构中重复了，我们再看一下正则尝试匹配的次数（示例），可以看到只尝试匹配了 57 次就结束了。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1509),alt:"img"}})]),s._v(" "),n("p",[n("strong",[s._v("所以一定要记住，不要在多选择分支中，出现重复的元素")]),s._v("。到这里，你对之前文章提到的「回溯不可怕，我们要尽量减少回溯后的判断」 是不是有了进一步的理解呢？")]),s._v(" "),n("p",[s._v("另外，之前我们说的独占模式，你可以把它可以理解为贪婪模式的一种优化，它也会发生广义的回溯，但它不会吐出已经匹配上的字符。独占模式匹配到英文逗号那儿，不会吐出已经匹配上的字符，匹配就失败了，所以采用独占模式也能解决性能问题。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1510),alt:"img"}})]),s._v(" "),n("p",[s._v("但要提醒你的是，独占模式 "),n("strong",[s._v("不吐出已匹配字符")]),s._v(" 的特性，会使得一些场景不能使用它。另外，只有少数编程语言支持独占模式。")]),s._v(" "),n("p",[s._v("解决这个问题还有其它的方式，比如我们可以 "),n("strong",[s._v("尝试移除多选分支选择结构")]),s._v("，"),n("strong",[s._v("直接用中括号表示多选一")])]),s._v(" "),n("p",[n("img",{attrs:{src:t(1511),alt:"img"}})]),s._v(" "),n("p",[s._v("我们会发现性能也是有显著提升（这里只是测试，真正使用的时候，重复的元素都应该去掉，另外这里也不需要保存子组）。")]),s._v(" "),n("h2",{attrs:{id:"优化建议"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化建议"}},[s._v("#")]),s._v(" 优化建议")]),s._v(" "),n("p",[s._v("学习了原理之后，有助于我们写出更好的正则。我们必须先保证正则的功能是正确的，然后再进行优化性能，下面我给了你一些优化的方法供你参考。")]),s._v(" "),n("h3",{attrs:{id:"_1-测试性能的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-测试性能的方法"}},[s._v("#")]),s._v(" 1. 测试性能的方法")]),s._v(" "),n("p",[s._v("我们可以使用 ipython 来测试正则的性能，ipython 是一个 Python shell 增强交互工具，在 "),n("code",[s._v("macOS/Windows/Linux")]),s._v(" 上都可以安装使用。在测试正则表达式时，它非常有用，比如下面通过一个示例，来测试在字符串中查找 abc 时的时间消耗。")]),s._v(" "),n("div",{staticClass:"language-bash line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# ipython 安装")]),s._v("\npip "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v("  ipython\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 验证")]),s._v("\n ipython\nPython "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.8")]),s._v(".6 "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("tags/v3.8.6:db45529, Sep "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("23")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),s._v(", "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v(":52:53"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("MSC v.1927 "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("64")]),s._v(" bit "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("AMD64"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\nType "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'copyright'")]),s._v(", "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'credits'")]),s._v(" or "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'license'")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("more")]),s._v(" information\nIPython "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("7.19")]),s._v(".0 -- An enhanced Interactive Python. Type "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'?'")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" help.\n\nIn "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(":    "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 就已经进入了 ipython 的交互式环境了")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 笔者这里测试，报 SyntaxError: invalid syntax")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[s._v("In "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" re\nIn "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'-'")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000000")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),s._v("\nIn "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" timeit re"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("search"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("480")]),s._v(" µs ± "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("8.06")]),s._v(" µs per loop "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("mean ± std"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" dev"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" of "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("7")]),s._v(" runs"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000")]),s._v(" loops each"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("另外，你也可以通过前面 regex101.com 查看正则和文本匹配的次数，来得知正则的性能信息。")]),s._v(" "),n("h3",{attrs:{id:"_2-提前编译好正则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-提前编译好正则"}},[s._v("#")]),s._v(" 2. 提前编译好正则")]),s._v(" "),n("p",[s._v("编程语言中一般都有 "),n("strong",[s._v("编译")]),s._v(" 方法，我们可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。")]),s._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[s._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" re\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" reg "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" re"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("compile")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("r'ab?c'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 先编译好，再使用")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" reg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("findall"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" re"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("findall"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("r'ab?c'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 正式使用不建议，但测试功能时较方便")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h3",{attrs:{id:"_3-尽量准确表示匹配范围"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-尽量准确表示匹配范围"}},[s._v("#")]),s._v(" 3. 尽量准确表示匹配范围")]),s._v(" "),n("p",[s._v("比如我们要匹配引号里面的内容，除了写成 "),n("code",[s._v('".+?"')]),s._v(" 之外，我们可以写成 "),n("code",[s._v('"[^"]+"')]),s._v('。使用 [^"] 要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题。')]),s._v(" "),n("p",[n("img",{attrs:{src:t(1512),alt:"image-20210112111200378"}})]),s._v(" "),n("p",[s._v("上面 的区别如下：")]),s._v(" "),n("ul",[n("li",[n("p",[n("code",[s._v('".+"')]),s._v("：如果使用贪婪模式，那么将会导致第一遍，将最后一个引号 "),n("code",[s._v('"')]),s._v(" 吃掉，再回溯（吐出来）匹配正则里面的最后一个引号")])]),s._v(" "),n("li",[n("p",[n("code",[s._v('".+?"')]),s._v("：使用了非贪婪模式，不会导致发生回溯")])]),s._v(" "),n("li",[n("p",[n("code",[s._v('"[^"]+"')]),s._v("：贪婪模式，引号开头结尾，中间用中括号选用非引号的字符出现 1 到多次")]),s._v(" "),n("p",[s._v("也不会发生回溯")])])]),s._v(" "),n("h3",{attrs:{id:"_4-提取出公共部分"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-提取出公共部分"}},[s._v("#")]),s._v(" 4. 提取出公共部分")]),s._v(" "),n("p",[s._v("通过上面对 NFA 引擎的学习，相信你应该明白 "),n("code",[s._v("(abcd|abxy)")]),s._v(" 这样的表达式，可以优化成 "),n("code",[s._v("ab(cd|xy)")]),s._v("，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率。")]),s._v(" "),n("p",[s._v("因此我们会知道 "),n("code",[s._v("th(?:is|at)")]),s._v(" 要比 "),n("code",[s._v("this|that")]),s._v(" 要快一些，但从可读性上看，后者要好一些，这个就需要用的时候去权衡，也可以添加代码注释让代码更容易理解。")]),s._v(" "),n("p",[s._v("类似地，如果是锚点，比如 "),n("code",[s._v("(^this|^that) is")]),s._v(" 这样的，锚点部分也应该独立出来，可以写成比如  "),n("code",[s._v("^th(is|at) is")]),s._v(" 的形式，因为锚点部分也是需要尝试去匹配的，匹配次数要尽可能少。")]),s._v(" "),n("h3",{attrs:{id:"_5-出现可能性大的放左边"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-出现可能性大的放左边"}},[s._v("#")]),s._v(" 5. 出现可能性大的放左边")]),s._v(" "),n("p",[n("strong",[s._v("由于正则是从左到右看的，把出现概率大的放左边")]),s._v("，域名中 "),n("code",[s._v(".com")]),s._v("  的使用是比 "),n("code",[s._v(".net")]),s._v("  多的，所以我们可以写成. "),n("code",[s._v("(?:com|net)\\b")]),s._v(" ，而不是 "),n("code",[s._v("\\.(?:net|com)\\b")]),s._v("。")]),s._v(" "),n("h3",{attrs:{id:"_6-只在必要时才使用子组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-只在必要时才使用子组"}},[s._v("#")]),s._v(" 6. 只在必要时才使用子组")]),s._v(" "),n("p",[s._v("在正则中，"),n("strong",[s._v("括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组")]),s._v("。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 "),n("code",[s._v("?:")]),s._v("  来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能。")]),s._v(" "),n("h3",{attrs:{id:"_7-警惕嵌套的子组重复"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-警惕嵌套的子组重复"}},[s._v("#")]),s._v(" 7. 警惕嵌套的子组重复")]),s._v(" "),n("p",[s._v("如果一个组里面包含重复，接着这个组整体也可以重复，比如 "),n("code",[s._v("(.*)*")]),s._v("  这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则。")]),s._v(" "),n("h3",{attrs:{id:"_8-避免不同分支重复匹配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-避免不同分支重复匹配"}},[s._v("#")]),s._v(" 8. 避免不同分支重复匹配")]),s._v(" "),n("p",[s._v("在多选分支选择中，要避免不同分支出现相同范围的情况，上面回溯的例子中，我们已经进行了比较详细的讲解。")]),s._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),n("p",[s._v("今天带你简单学习了有穷自动机的概念，自动机的具体实现称之为正则引擎。")]),s._v(" "),n("p",[s._v("我们学习了正则引擎的匹配原理，NFA 和 DFA 两种引擎的工作方式完全不同，NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA 是指符合 POSIX 标准的 NFA 引擎，它会不断回溯，以确保找到最左侧最长匹配。")]),s._v(" "),n("p",[s._v("接着我们学习了测试正则表达式性能的方法，以及优化的一些方法，比如提前编译好正则，提取出公共部分，尽量准确地表示范围，必要时才使用子组等。")]),s._v(" "),n("p",[n("img",{attrs:{src:t(1513),alt:"image-20210112112818541"}})]),s._v(" "),n("h2",{attrs:{id:"课后思考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#课后思考"}},[s._v("#")]),s._v(" 课后思考")]),s._v(" "),n("p",[s._v("最后，我们来做一个小练习吧。通过今天学习的内容，这里有一个示例，要求匹配： "),n("strong",[s._v("由字母或数字组成的字符串，但第一个字符要是小写英文字母，你能说一下针对这个示例，NFA 引擎的匹配过程么？")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("文本：a12\n正则：^(?=[a-z])[a-z0-9]+$\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("答：环视只匹配位置，是零宽度的，区别就在于这儿。")]),s._v(" "),n("p",[s._v("元字符 "),n("code",[s._v("^")]),s._v(" 和 "),n("code",[s._v("$")]),s._v(" 匹配的只是位置，顺序环视 "),n("code",[s._v("(?=[a-z])")]),s._v(" 只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。")]),s._v(" "),n("p",[s._v("匹配过程：")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("首先由元字符 "),n("code",[s._v("^")]),s._v(" 取得控制权，从位置 0 开始匹配，"),n("code",[s._v("^")]),s._v(" 匹配的就是开始位置 "),n("code",[s._v("位置0")]),s._v(" ，匹配成功，控制权交给顺序环视 "),n("code",[s._v("(?=[a-z])")]),s._v("；")])]),s._v(" "),n("li",[n("p",[n("code",[s._v("(?=[a-z])")]),s._v(" 要求它所在位置右侧必须是字母才能匹配成功，"),n("strong",[s._v("零宽度的子表达式之间是不互斥的")]),s._v("，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置 0 尝试进行匹配，位置 0 的右侧是字符 "),n("code",[s._v("a")]),s._v("，符合要求，匹配成功，控制权交给 "),n("code",[s._v("[a-z0-9]+")]),s._v("；")])]),s._v(" "),n("li",[n("p",[s._v("因为 "),n("code",[s._v("(?=[a-z])")]),s._v(" 只进行匹配，并不将匹配到的内容保存到最后结果，并且 "),n("code",[s._v("(?=[a-z])")]),s._v(" 匹配成功的位置是位置 0，所以 "),n("code",[s._v("[a-z0-9]+")]),s._v(" 也是从位置 0 开始尝试匹配的，"),n("code",[s._v("[a-z0-9]+")]),s._v(" 首先尝试匹配 "),n("code",[s._v("a")]),s._v("，匹配成功，继续尝试匹配，可以成功匹配接下来的 "),n("code",[s._v("1")]),s._v(" 和 "),n("code",[s._v("2")]),s._v(" ，此时已经匹配到位置 3，位置 3 的右侧已没有字符，这时会把控制权交给 "),n("code",[s._v("$")]),s._v("；")])]),s._v(" "),n("li",[n("p",[s._v("元字符 "),n("code",[s._v("$")]),s._v(" 从位置 3 开始尝试匹配，它匹配的是结束位置，也就是 "),n("code",[s._v("位置 3")]),s._v("，匹配成功。")])])]),s._v(" "),n("p",[s._v("此时正则表达式匹配完成，报告匹配成功。匹配结果为 "),n("code",[s._v("a12")]),s._v(" ，开始位置为 0，结束位置为 3。其中：")]),s._v(" "),n("ul",[n("li",[n("code",[s._v("^")]),s._v(" 匹配位置"),n("code",[s._v("0")]),s._v("，")]),s._v(" "),n("li",[n("code",[s._v("(?=[a-z])")]),s._v(" 匹配位置 0")]),s._v(" "),n("li",[n("code",[s._v("[a-z0-9]+")]),s._v(" 匹配字符串 "),n("code",[s._v("a12")])]),s._v(" "),n("li",[n("code",[s._v("$")]),s._v(" 匹配位置 3。")])]),s._v(" "),n("p",[s._v("可以参考 https://blog.csdn.net/lxcnn/article/details/4304651")])])}),[],!1,null,null,null);a.default=e.exports}}]);